// Comprehensive penetration testing and security audit
import fs from 'fs';

console.log('🔐 COMPREHENSIVE SECURITY PENETRATION TEST\n');

const vulnerabilityTests = {
  // Test 1: Authentication Security
  authSecurity: () => {
    console.log('1. Testing Authentication Security...');
    const issues = [];
    
    try {
      const routesFile = fs.readFileSync('./server/routes.ts', 'utf8');
      const manualOauthFile = fs.readFileSync('./server/manual-oauth.ts', 'utf8');
      
      // Check for proper session configuration
      if (!routesFile.includes('session') && !manualOauthFile.includes('session')) {
        issues.push('No session management detected');
      }
      
      // Check for password hashing
      if (routesFile.includes('password') && !routesFile.includes('bcrypt')) {
        issues.push('Passwords may not be properly hashed');
      }
      
      // Check for OAuth security
      if (manualOauthFile.includes('state') === false) {
        issues.push('OAuth state parameter missing (CSRF protection)');
      }
      
    } catch (e) {
      issues.push('Cannot analyze authentication files');
    }
    
    return issues;
  },

  // Test 2: Input Validation & Injection Attacks
  injectionTests: () => {
    console.log('2. Testing Injection Attack Prevention...');
    const issues = [];
    
    try {
      const storageFile = fs.readFileSync('./server/storage.ts', 'utf8');
      const routesFile = fs.readFileSync('./server/routes.ts', 'utf8');
      
      // Check SQL injection protection
      if (!storageFile.includes('eq(') || !storageFile.includes('drizzle-orm')) {
        issues.push('SQL injection vulnerability: Not using parameterized queries');
      }
      
      // Check for input sanitization
      if (!routesFile.includes('sanitize') && !routesFile.includes('validator')) {
        issues.push('Missing input sanitization middleware');
      }
      
      // Check for NoSQL injection protection
      const securityFile = fs.readFileSync('./server/security.ts', 'utf8');
      if (!securityFile.includes('mongoSanitize') && !routesFile.includes('mongo-sanitize')) {
        issues.push('Missing NoSQL injection protection');
      }
      
    } catch (e) {
      issues.push('Cannot analyze injection protection');
    }
    
    return issues;
  },

  // Test 3: Session & Cookie Security
  sessionSecurity: () => {
    console.log('3. Testing Session & Cookie Security...');
    const issues = [];
    
    try {
      const securityFile = fs.readFileSync('./server/security.ts', 'utf8');
      const indexFile = fs.readFileSync('./server/index.ts', 'utf8');
      
      // Check for secure session configuration
      if (!indexFile.includes('secureSessionConfig')) {
        issues.push('Session security configuration not found');
      }
      
      // Check environment variables
      if (!process.env.SESSION_SECRET) {
        issues.push('SESSION_SECRET environment variable missing');
      }
      
    } catch (e) {
      issues.push('Cannot analyze session security');
    }
    
    return issues;
  },

  // Test 4: HTTPS & Transport Security
  transportSecurity: () => {
    console.log('4. Testing Transport Security...');
    const issues = [];
    
    try {
      const securityFile = fs.readFileSync('./server/security.ts', 'utf8');
      
      // Check for HSTS
      if (!securityFile.includes('hsts')) {
        issues.push('HSTS (HTTP Strict Transport Security) not configured');
      }
      
      // Check for secure cookie settings
      if (!securityFile.includes('secure:') || !securityFile.includes('httpOnly:')) {
        issues.push('Cookies not configured with secure flags');
      }
      
    } catch (e) {
      issues.push('Cannot analyze transport security');
    }
    
    return issues;
  },

  // Test 5: Rate Limiting & DoS Protection
  dosProtection: () => {
    console.log('5. Testing DoS Protection...');
    const issues = [];
    
    try {
      const securityFile = fs.readFileSync('./server/security.ts', 'utf8');
      const indexFile = fs.readFileSync('./server/index.ts', 'utf8');
      
      // Check for rate limiting
      if (!securityFile.includes('rateLimit') || !indexFile.includes('rateLimiter')) {
        issues.push('Rate limiting not implemented');
      }
      
      // Check for request size limits
      if (!indexFile.includes('limit:')) {
        issues.push('Request size limits not configured');
      }
      
    } catch (e) {
      issues.push('Cannot analyze DoS protection');
    }
    
    return issues;
  },

  // Test 6: Data Exposure & Privacy
  dataExposure: () => {
    console.log('6. Testing Data Exposure Prevention...');
    const issues = [];
    
    try {
      const clientFiles = fs.readdirSync('./client/src', { recursive: true });
      
      // Check for exposed secrets in client
      clientFiles.forEach(file => {
        if (file.endsWith('.tsx') || file.endsWith('.ts')) {
          try {
            const content = fs.readFileSync(`./client/src/${file}`, 'utf8');
            if (content.includes('process.env') && !content.includes('import.meta.env')) {
              issues.push(`Client file ${file} using process.env instead of import.meta.env`);
            }
          } catch (e) {
            // Skip files that can't be read
          }
        }
      });
      
    } catch (e) {
      issues.push('Cannot analyze client-side data exposure');
    }
    
    return issues;
  }
};

// Run comprehensive security tests
let totalVulnerabilities = 0;
let criticalIssues = 0;

Object.keys(vulnerabilityTests).forEach(testName => {
  const vulnerabilities = vulnerabilityTests[testName]();
  
  if (vulnerabilities.length > 0) {
    console.log(`   🚨 ${vulnerabilities.length} vulnerability(ies) found:`);
    vulnerabilities.forEach(vuln => {
      console.log(`      - ${vuln}`);
      if (vuln.includes('injection') || vuln.includes('SESSION_SECRET') || vuln.includes('process.env')) {
        criticalIssues++;
      }
    });
    totalVulnerabilities += vulnerabilities.length;
  } else {
    console.log('   ✅ No vulnerabilities detected');
  }
  console.log('');
});

// Security assessment
console.log('🔐 SECURITY ASSESSMENT COMPLETE');
console.log(`📊 Total vulnerabilities found: ${totalVulnerabilities}`);
console.log(`🚨 Critical vulnerabilities: ${criticalIssues}`);

if (totalVulnerabilities === 0) {
  console.log('✅ SYSTEM SECURE - Ready for production deployment');
} else if (criticalIssues === 0) {
  console.log('⚠️  Minor security improvements needed before production');
} else {
  console.log('🚨 CRITICAL VULNERABILITIES - Must fix before production');
}

// Production readiness score
const maxScore = Object.keys(vulnerabilityTests).length * 10;
const securityScore = Math.max(0, maxScore - (totalVulnerabilities * 2) - (criticalIssues * 5));
console.log(`🏆 Security Score: ${securityScore}/${maxScore} (${Math.round(securityScore/maxScore * 100)}%)`);