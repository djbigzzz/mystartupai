#!/usr/bin/env node

/**
 * Comprehensive Security Penetration Test
 * Tests for common vulnerabilities including injection attacks, authentication bypasses, etc.
 */

import http from 'http';
import https from 'https';

const BASE_URL = 'http://localhost:5000';

// Test payloads for different attack vectors
const SQL_INJECTION_PAYLOADS = [
  "'; DROP TABLE users; --",
  "' OR '1'='1",
  "' UNION SELECT * FROM users --",
  "admin'--",
  "admin' /*",
  "' OR 1=1#",
  "') OR '1'='1--",
  "1' AND (SELECT COUNT(*) FROM users) > 0--"
];

const XSS_PAYLOADS = [
  "<script>alert('XSS')</script>",
  "<img src=x onerror=alert('XSS')>",
  "javascript:alert('XSS')",
  "<svg onload=alert('XSS')>",
  "';alert('XSS');//",
  "<iframe src=javascript:alert('XSS')></iframe>",
  "<body onload=alert('XSS')>",
  "<input autofocus onfocus=alert('XSS')>"
];

const COMMAND_INJECTION_PAYLOADS = [
  "; cat /etc/passwd",
  "| whoami",
  "&& rm -rf /",
  "`cat /etc/hosts`",
  "$(whoami)",
  "; ls -la",
  "& ping google.com",
  "| cat /proc/version"
];

const NOSQL_INJECTION_PAYLOADS = [
  '{"$where": "this.username == this.password"}',
  '{"$regex": ".*"}',
  '{"$ne": null}',
  '{"$exists": true}',
  '{"$gt": ""}',
  '{"username": {"$ne": null}, "password": {"$ne": null}}'
];

const PATH_TRAVERSAL_PAYLOADS = [
  "../../../etc/passwd",
  "..\\..\\..\\windows\\system32\\config\\sam",
  "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
  "....//....//....//etc//passwd",
  "../../../../../boot.ini"
];

// Helper function to make HTTP requests
function makeRequest(method, path, data = null, headers = {}) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, BASE_URL);
    const options = {
      method,
      hostname: url.hostname,
      port: url.port,
      path: url.pathname + url.search,
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Security-Pentest/1.0',
        ...headers
      }
    };

    if (data && method !== 'GET') {
      const payload = JSON.stringify(data);
      options.headers['Content-Length'] = Buffer.byteLength(payload);
    }

    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => body += chunk);
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          body: body,
          data: body ? (body.startsWith('{') ? JSON.parse(body) : body) : null
        });
      });
    });

    req.on('error', reject);

    if (data && method !== 'GET') {
      req.write(JSON.stringify(data));
    }
    
    req.end();
  });
}

// Test SQL Injection vulnerabilities
async function testSQLInjection() {
  console.log('\nüîç Testing SQL Injection vulnerabilities...');
  const vulnerabilities = [];

  const endpoints = [
    { path: '/api/auth/login', method: 'POST', params: ['email', 'password'] },
    { path: '/api/auth/register', method: 'POST', params: ['email', 'password', 'name'] },
    { path: '/api/ideas', method: 'POST', params: ['ideaTitle', 'description', 'industry'] },
    { path: '/api/waitlist', method: 'POST', params: ['email', 'name'] }
  ];

  for (const endpoint of endpoints) {
    for (const payload of SQL_INJECTION_PAYLOADS) {
      try {
        const testData = {};
        endpoint.params.forEach(param => {
          testData[param] = payload;
        });

        const response = await makeRequest(endpoint.method, endpoint.path, testData);
        
        // Check for SQL error messages or unexpected behavior
        const bodyStr = JSON.stringify(response.body || '').toLowerCase();
        const sqlErrorPatterns = [
          'sql syntax', 'mysql', 'postgresql', 'sqlite', 'ora-', 'error in your sql',
          'quoted string not properly terminated', 'syntax error', 'database error'
        ];

        const hasSqlError = sqlErrorPatterns.some(pattern => bodyStr.includes(pattern));
        
        if (hasSqlError || response.statusCode === 500) {
          vulnerabilities.push({
            endpoint: endpoint.path,
            payload: payload,
            response: response.statusCode,
            issue: 'Potential SQL injection vulnerability detected'
          });
        }
      } catch (error) {
        // Network errors might indicate successful injection
        if (error.code === 'ECONNRESET') {
          vulnerabilities.push({
            endpoint: endpoint.path,
            payload: payload,
            issue: 'Connection reset - possible SQL injection'
          });
        }
      }
    }
  }

  return vulnerabilities;
}

// Test XSS vulnerabilities
async function testXSS() {
  console.log('\nüîç Testing XSS vulnerabilities...');
  const vulnerabilities = [];

  const endpoints = [
    { path: '/api/ideas', method: 'POST', params: ['ideaTitle', 'description'] },
    { path: '/api/waitlist', method: 'POST', params: ['name', 'email'] }
  ];

  for (const endpoint of endpoints) {
    for (const payload of XSS_PAYLOADS) {
      try {
        const testData = {};
        endpoint.params.forEach(param => {
          testData[param] = param === 'email' ? 'test@example.com' : payload;
        });

        const response = await makeRequest(endpoint.method, endpoint.path, testData);
        
        // Check if XSS payload is reflected in response
        const bodyStr = JSON.stringify(response.body || '');
        if (bodyStr.includes(payload) || bodyStr.includes('alert(')) {
          vulnerabilities.push({
            endpoint: endpoint.path,
            payload: payload,
            issue: 'Potential XSS vulnerability - payload reflected in response'
          });
        }
      } catch (error) {
        // Continue with other tests
      }
    }
  }

  return vulnerabilities;
}

// Test Authentication bypass
async function testAuthBypass() {
  console.log('\nüîç Testing authentication bypass vulnerabilities...');
  const vulnerabilities = [];

  const protectedEndpoints = [
    '/api/auth/me',
    '/api/ideas/1',
    '/api/business-plans/1',
    '/api/pitch-decks/1'
  ];

  for (const endpoint of protectedEndpoints) {
    try {
      // Test without authentication
      const response = await makeRequest('GET', endpoint);
      
      if (response.statusCode === 200) {
        vulnerabilities.push({
          endpoint: endpoint,
          issue: 'Authentication bypass - endpoint accessible without auth'
        });
      }

      // Test with invalid session
      const responseWithFakeSession = await makeRequest('GET', endpoint, null, {
        'Cookie': 'session=invalid_session_token'
      });

      if (responseWithFakeSession.statusCode === 200) {
        vulnerabilities.push({
          endpoint: endpoint,
          issue: 'Session validation bypass detected'
        });
      }

    } catch (error) {
      // Continue with other tests
    }
  }

  return vulnerabilities;
}

// Test rate limiting
async function testRateLimit() {
  console.log('\nüîç Testing rate limiting...');
  const vulnerabilities = [];

  const endpoints = [
    { path: '/api/auth/login', method: 'POST' },
    { path: '/api/waitlist', method: 'POST' }
  ];

  for (const endpoint of endpoints) {
    try {
      const requests = [];
      
      // Send 20 requests rapidly
      for (let i = 0; i < 20; i++) {
        requests.push(makeRequest(endpoint.method, endpoint.path, {
          email: `test${i}@example.com`,
          password: 'testpass',
          name: 'Test User'
        }));
      }

      const responses = await Promise.all(requests);
      const rateLimitedRequests = responses.filter(r => r.statusCode === 429);

      if (rateLimitedRequests.length === 0) {
        vulnerabilities.push({
          endpoint: endpoint.path,
          issue: 'Rate limiting not properly implemented'
        });
      }

    } catch (error) {
      // Continue with other tests
    }
  }

  return vulnerabilities;
}

// Test CSRF protection
async function testCSRF() {
  console.log('\nüîç Testing CSRF protection...');
  const vulnerabilities = [];

  const endpoints = [
    { path: '/api/auth/login', method: 'POST' },
    { path: '/api/ideas', method: 'POST' }
  ];

  for (const endpoint of endpoints) {
    try {
      // Test without CSRF token
      const response = await makeRequest(endpoint.method, endpoint.path, {
        email: 'test@example.com',
        password: 'testpass'
      });

      // If request succeeds without CSRF token, it's vulnerable
      if (response.statusCode === 200) {
        vulnerabilities.push({
          endpoint: endpoint.path,
          issue: 'CSRF protection not implemented'
        });
      }

    } catch (error) {
      // Continue with other tests
    }
  }

  return vulnerabilities;
}

// Test input validation
async function testInputValidation() {
  console.log('\nüîç Testing input validation...');
  const vulnerabilities = [];

  const testCases = [
    {
      endpoint: '/api/ideas',
      method: 'POST',
      data: {
        ideaTitle: 'A'.repeat(10000), // Very long string
        description: 'Test',
        industry: 'Tech'
      }
    },
    {
      endpoint: '/api/waitlist',
      method: 'POST', 
      data: {
        email: 'not-an-email',
        name: '<script>alert("xss")</script>'
      }
    }
  ];

  for (const testCase of testCases) {
    try {
      const response = await makeRequest(testCase.method, testCase.endpoint, testCase.data);
      
      if (response.statusCode === 200 || response.statusCode === 201) {
        vulnerabilities.push({
          endpoint: testCase.endpoint,
          issue: 'Input validation bypass - invalid data accepted'
        });
      }

    } catch (error) {
      // Continue with other tests
    }
  }

  return vulnerabilities;
}

// Main penetration test function
async function runPenetrationTest() {
  console.log('üõ°Ô∏è  Starting Security Penetration Test...\n');
  console.log(`Target: ${BASE_URL}`);
  
  const allVulnerabilities = [];

  try {
    // Run all security tests
    const sqlInjectionVulns = await testSQLInjection();
    const xssVulns = await testXSS();
    const authBypassVulns = await testAuthBypass();
    const rateLimitVulns = await testRateLimit();
    const csrfVulns = await testCSRF();
    const inputValidationVulns = await testInputValidation();

    allVulnerabilities.push(...sqlInjectionVulns);
    allVulnerabilities.push(...xssVulns);
    allVulnerabilities.push(...authBypassVulns);
    allVulnerabilities.push(...rateLimitVulns);
    allVulnerabilities.push(...csrfVulns);
    allVulnerabilities.push(...inputValidationVulns);

    // Report results
    console.log('\nüìä PENETRATION TEST RESULTS');
    console.log('='.repeat(50));
    
    if (allVulnerabilities.length === 0) {
      console.log('‚úÖ No vulnerabilities detected! Platform appears secure.');
    } else {
      console.log(`üö® Found ${allVulnerabilities.length} potential vulnerabilities:\n`);
      
      allVulnerabilities.forEach((vuln, index) => {
        console.log(`${index + 1}. ${vuln.issue}`);
        console.log(`   Endpoint: ${vuln.endpoint}`);
        if (vuln.payload) console.log(`   Payload: ${vuln.payload}`);
        if (vuln.response) console.log(`   Response: ${vuln.response}`);
        console.log('');
      });
    }

    console.log('='.repeat(50));
    console.log('üõ°Ô∏è  Penetration test completed.\n');

    return allVulnerabilities;

  } catch (error) {
    console.error('‚ùå Error during penetration test:', error);
    return [];
  }
}

// Run the test
if (import.meta.url === `file://${process.argv[1]}`) {
  runPenetrationTest()
    .then(vulnerabilities => {
      process.exit(vulnerabilities.length > 0 ? 1 : 0);
    })
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}

export { runPenetrationTest };